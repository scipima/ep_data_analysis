---
title: "EP Groups' Divisions"
author:
  - Marco SCIPIONI
date: "`r Sys.Date()`"
format: 
  html:
    embed-resources: true
    toc: true
    toc-depth: 4
    toc-title: Contents
    number-sections: true
    colorlinks: true
editor_options: 
  chunk_output_type: console
execute:
  echo: false
  warning: false
---

## Intro
```{r}
#| include: false

#------------------------------------------------------------------------------#
## Libraries -------------------------------------------------------------------
if ( !require("pacman") ) install.packages("pacman")
pacman::p_load(char = c("data.table", "dplyr", "forcats", "ggplot2", "here",
                        "lubridate", "janitor", "tidyr", "tidyselect", "tidytext") )


#------------------------------------------------------------------------------#
# Hard code the start of the mandate ------------------------------------------#
mandate_starts <- as.Date("2024-07-14")


#------------------------------------------------------------------------------#
## Functions -------------------------------------------------------------------
# https://stackoverflow.com/questions/2547402/how-to-find-the-statistical-mode
stat_mode <- function(x) {
  if ( length(x) <= 2 ) return(x[1])
  if ( anyNA(x) ) x = x[!is.na(x)]
  ux <- unique(x)
  ux[ which.max( tabulate( match(x, ux) ) ) ] }

# Load join functions ---------------------------------------------------------#
source(file = here::here("scripts_r", "join_functions.R") )  

# Calculate Majorities --------------------------------------------------------#
source(file = here::here("scripts_r", "get_majority.R") )


###--------------------------------------------------------------------------###
## Graphics --------------------------------------------------------------------
# Set global theme for ggplot2 ------------------------------------------------#
# https://stackoverflow.com/questions/34522732/changing-fonts-in-ggplot2
theme_set(theme_minimal(base_size = 10))

# vote colours  -------------------------------------------------------------###
vote_colours <- c(For = '#00AEEF',
                  Against = '#BE3455',
                  Abstain = "#969696",
                  `Did not vote` = '#5D5CA4',
                  Absent = '#F47920')
```

```{r}
#| include: false

###--------------------------------------------------------------------------###
## Read data -------------------------------------------------------------------
### RCV ------------------------------------------------------------------------
meps_rcv_mandate <- data.table::fread(
  file = here::here("data_out", "meps_rcv_mandate_10.csv"),
  verbose = TRUE, key = c("rcv_id", "pers_id"), 
  na.strings = c(NA_character_, "") )

### Votes ----------------------------------------------------------------------
pl_votes <- data.table::fread(
  file = here::here("data_out", "votes", "pl_votes_10.csv"), 
  select = c("activity_date", "rcv_id", "mandate", "number_of_attendees", 
             "number_of_votes_abstention", "number_of_votes_against",
             "number_of_votes_favor"), 
  na.strings = c(NA_character_, "") )

### MEP last Plenary day -------------------------------------------------------
meps_current <- data.table::fread( file = here::here(
  "data_out", "meps", "meps_current.csv") )

### RCV ID and Committees ------------------------------------------------------
rcvid_cmts_10 <- data.table::fread(input = here::here(
  "data_out", "rcv", "rcvid_cmts_10.csv") ) |> 
  dplyr::filter(committee_lab != "NULL")
rcvid_cmts_10[committee_lab == "BUDE", committee_lab := "BUDG"]

#------------------------------------------------------------------------------#
# get length objects
n_votes <- nrow(pl_votes)
n_rcv <- length( unique( meps_rcv_mandate$rcv_id ) )

#------------------------------------------------------------------------------#
# Hard code Groups
renew_group_ids <- political_groups$identifier[
  political_groups$label == "Renew"]
```

The objectives of this short note is to identify **divisions** and **splits** within EP Political Groups.
To achieve that, we first calculate the average distance between the Groups' majorities and all of their current national parties.
Second, we re-calculate these distances broken down by Committees, to check whether differences tend to accumulate in specific policy areas. 
As a caveat, at the time of writing we have an extremely low sample sizes in certain Committees.
Results for these subsections will become more insightful as the data accumulate.
For presentational purposes, every Group has a dedicated section. 

**Please keep in mind** that this document is the *sole property of the Renew Group* and *should not be disseminated to other people or organisations*.


## Splits within Groups
```{r}
#------------------------------------------------------------------------------#
#' In order to have the majorities correctly lined up with their histories, we need first to get the grid to match to.
#' Then we calculate the majorities for both political groups and national parties, and finally we join all the data.
#------------------------------------------------------------------------------#

# Data entry mistake
meps_rcv_mandate[natparty_id == 5320L, natparty_id := 6708L]


# RCV grid --------------------------------------------------------------------#
rcv_grid <- unique(
  meps_rcv_mandate[order(polgroup_id, natparty_id, rcv_id),
                   list(polgroup_id, country_id, natparty_id, rcv_id)])
# sapply(rcv_grid, function(x) sum(is.na(x)))


# Get the target group majority -----------------------------------------------#
polgroup_majorities <- get_polgroup_majority(
  data_in = meps_rcv_mandate[
    result >= -1]) # exclude absent
# sapply(polgroup_majorities, function(x) sum(is.na(x)))


# Get the target parties majority ---------------------------------------------#
natparty_majorities <- get_natparty_majority(
  data_in = meps_rcv_mandate[
    result >= -1]) # exclude absent
# sapply(natparty_majorities, function(x) sum(is.na(x)))


# Inner-join ------------------------------------------------------------------#
igroup_iparty <- rcv_grid[
  polgroup_majorities,
  on = c("polgroup_id", "rcv_id"),
  nomatch = NULL
]
# sapply(igroup_iparty, function(x) sum(is.na(x)))
# dim(igroup_iparty)

igroup_iparty <- igroup_iparty[
  natparty_majorities, 
  on = c("polgroup_id", "natparty_id", "rcv_id"),
  nomatch = NULL
]
# sapply(igroup_iparty, function(x) sum(is.na(x)))
# dim(igroup_iparty)


# Calculate Euclidean distance
igroup_iparty[, `:=`(
  eucl_dist = sqrt((result - i.result)^2) # 0 if same, 2 if distant
)]

# take the average for plotting
dist_avg_dt <- igroup_iparty[, list(
  eucl_dist_avg = mean(eucl_dist, na.rm = TRUE) ),
  by = list(country_id, polgroup_id, natparty_id)
][, `:=`(
  # normalise the euclidean for comparable plotting
  eucl_dist_avg_norm = eucl_dist_avg / 2L
)]


# Inner-join with Committees --------------------------------------------------#
igroup_iparty_cmt <- igroup_iparty[
  rcvid_cmts_10,
  on = "rcv_id",
  nomatch = NULL
]

# take the average for plotting
dist_avg_cmt_dt <- igroup_iparty_cmt[, list(
  eucl_dist_avg = mean(eucl_dist, na.rm = TRUE) ),
  by = list(country_id, polgroup_id, natparty_id, committee_lab)
][, `:=`(
  # normalise the euclidean for comparable plotting
  eucl_dist_avg_norm = eucl_dist_avg / 2L
)]
```

Affinity is defined as the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance) between Renew's majority and all other MEPs.
The assumption here is that there is a qualitative difference between *abstaining* and voting *against*, with the latter expressing a more profound disagreement with those who voted in *favour*.
To measure affinity, we consider only EP official votes, that is `for`, `against`, `abstain`.
```{r}
# plot -------------------------------------------------------------------------
group_party_plot <- function(i_polgroup = "PPE") {
  dist_avg_dt |>  
    dplyr::inner_join(
      y = unique(meps_current[, list(country_id, polgroup_id, natparty_id)]),
      by = c("country_id", "polgroup_id", "natparty_id") ) |> 
    join_polit_labs() |> 
    join_meps_countries() |> 
    dplyr::filter(political_group %in% i_polgroup) |>  
    dplyr::mutate(
      national_party = paste(country_iso3c, national_party, sep = " - "),
      national_party = forcats::fct_reorder(.f = national_party,
                                            .x = eucl_dist_avg_norm) ) |> 
    ggplot(aes(x = national_party, 
               y = eucl_dist_avg_norm) ) +
    geom_col(fill="grey", colour="black", linewidth=0.1) +
    geom_hline(yintercept = 0, linewidth=0.5) +
    labs(
      x="", y="Normalised euclidean distance",
      title = "Distance between Group's majority and all of its national parties",
      subtitle = "The lower the value, the greater the affinity with Group majority.",
      caption = "Source: EP. Notes: data is relative to RCVs in Plenary.") +
    coord_flip() +
    theme_minimal() +
    theme(plot.title.position = "plot",
          plot.title = element_text(face = "bold"),
          legend.text = element_text(face="bold"),
          panel.grid.major.x = element_line(colour = "grey30", linewidth = 0.2),
          panel.grid.minor.x = element_line(colour = "grey70", linewidth = 0.1),
          # panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
          # panel.grid.minor.y = element_line(colour = "grey30", linewidth = 0.1),
          axis.text = element_text(face="bold"),
          legend.position = "right") 
}


group_party_cmt_plot <- function(i_polgroup = "PPE") {
  dist_avg_cmt_dt |>  
    dplyr::inner_join(
      y = unique(meps_current[, list(country_id, polgroup_id, natparty_id)]),
      by = c("country_id", "polgroup_id", "natparty_id") ) |> 
    join_polit_labs() |> 
    join_meps_countries() |> 
    dplyr::filter(political_group %in% i_polgroup) |>  
    dplyr::mutate(
      national_party = paste(country_iso3c, national_party, sep = " - ")
    ) |> 
    ggplot(aes(x = committee_lab, y = forcats::fct_rev(national_party),
               fill = eucl_dist_avg_norm) ) +
    geom_tile(colour="black", linewidth=0.1) +
    labs(
      x="", y="", fill="Normalised euclidean distance",
      title = "Distance between Group's majority and all of its national parties, by Committee",
      subtitle = "The lower the value, the greater the affinity with Group majority.",
      caption = "Source: EP. Notes: data is relative to RCVs in Plenary.") +
    scale_fill_distiller(direction = -1, type = "div", palette = 7,
                         na.value = "grey20") +
    theme(plot.title.position = "plot",
          plot.title = element_text(face = "bold"),
          legend.position = "top",
          legend.text = element_text(face="bold"),
          legend.title = element_text(vjust = 0.8),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.y = element_blank(),
          axis.text.y = element_text(face="bold"),
          axis.text.x = element_text(face = "bold", angle = 90)) 
}
```


### EPP
#### Overall affinity
The plot is ranked by parties' affinity with the respective Group's majority, with the farthest party at the top, and closest ones at the bottom.
```{r}
#| fig-height: 8

group_party_plot(i_polgroup = "PPE")
```


#### By Committee
```{r}
#| fig-height: 8

group_party_cmt_plot(i_polgroup = "PPE")
```


### S&D
#### Overall affinity
```{r}
#| fig-height: 6

group_party_plot(i_polgroup = "S&D")
```


#### By Committee
```{r}
#| fig-height: 6

group_party_cmt_plot(i_polgroup = "S&D")
```


### Verts/ALE
#### Overall affinity
```{r}
#| fig-height: 5

group_party_plot(i_polgroup = "Verts/ALE")
```


#### By Committee
```{r}
#| fig-height: 5

group_party_cmt_plot(i_polgroup = "Verts/ALE")
```


### ECR
#### Overall affinity
```{r}
#| fig-height: 5

group_party_plot(i_polgroup = "ECR")
```


#### By Committee
```{r}
#| fig-height: 5

group_party_cmt_plot(i_polgroup = "ECR")
```


### PfE
#### Overall affinity
```{r}
#| fig-height: 4

group_party_plot(i_polgroup = "PfE")
```


#### By Committee
```{r}
#| fig-height: 4

group_party_cmt_plot(i_polgroup = "PfE")
```


### ESN
#### Overall affinity
```{r}
#| fig-height: 3

group_party_plot(i_polgroup = "ESN")
```


#### By Committee
```{r}
#| fig-height: 3

group_party_cmt_plot(i_polgroup = "ESN")
```


### The Left
#### Overall affinity
```{r}
#| fig-height: 4.5

group_party_plot(i_polgroup = "The Left")
```


#### By Committee
```{r}
#| fig-height: 4.5

group_party_cmt_plot(i_polgroup = "The Left")
```

## Data and Methods
We include in our analysis all voting data relative to roll-call votes (RCVs) during the current mandate.
To provide some context, we currently have `r length(unique(meps_rcv_mandate$rcv_id))` RCVs in our database for the current mandate.
It is important to appreciate that what we have is only a subset of the all legislation being adopted. 
Indeed, the EP recognises different forms of voting - such as *raise of hands*, or *electronic votes* - but RCVs are the only ones where we able to trace votes to individual MEPs - that is, they are so-called *nominal* votes. 
As a rough approximation, if we take out the likely duplicate rows from the voting archives, RCVs were approximately `r round(n_rcv/n_votes*100, digits=1)`% of the total votes during this mandate.
