---
title: "Listing Renew Europe-compatible MEPs outside the Group"
author:
  - Marco SCIPIONI
date: "`r Sys.Date()`"
format: 
  pdf:
    # sansfont: "Arial"
    # mainfont: "Arial"
    number-sections: true
    colorlinks: true
    geometry:
      - top=10mm
      - left=10mm
      - bottom=20mm
      - right=10mm
editor_options: 
  chunk_output_type: console
execute:
  echo: false
  warning: false
---

## Intro
```{r}
#| include: false

#------------------------------------------------------------------------------#
## Libraries -------------------------------------------------------------------
if ( !require("pacman") ) install.packages("pacman")
pacman::p_load(char = c("data.table", "dplyr", "forcats", "ggplot2", "here",
                        "lubridate", "janitor", "tidyr", "tidyselect", "tidytext") )


#------------------------------------------------------------------------------#
# Hard code the start of the mandate ------------------------------------------#
mandate_starts <- as.Date("2024-07-14")


#------------------------------------------------------------------------------#
## Functions -------------------------------------------------------------------
# https://stackoverflow.com/questions/2547402/how-to-find-the-statistical-mode
stat_mode <- function(x) {
  if ( length(x) <= 2 ) return(x[1])
  if ( anyNA(x) ) x = x[!is.na(x)]
  ux <- unique(x)
  ux[ which.max( tabulate( match(x, ux) ) ) ] }

# Load join functions ---------------------------------------------------------#
source(file = here::here("scripts_r", "join_functions.R") )  

# Calculate Majorities --------------------------------------------------------#
source(file = here::here("scripts_r", "get_majority.R") )


###--------------------------------------------------------------------------###
## Graphics --------------------------------------------------------------------
# Set global theme for ggplot2 ------------------------------------------------#
# https://stackoverflow.com/questions/34522732/changing-fonts-in-ggplot2
theme_set(theme_minimal(base_size = 10))

# vote colours  -------------------------------------------------------------###
vote_colours <- c(For = '#00AEEF',
                  Against = '#BE3455',
                  Abstain = "#969696",
                  `Did not vote` = '#5D5CA4',
                  Absent = '#F47920')
```

```{r}
#| include: false

###--------------------------------------------------------------------------###
## Read data -------------------------------------------------------------------
### RCV ------------------------------------------------------------------------
meps_rcv_mandate <- data.table::fread(
  file = here::here("data_out", "meps_rcv_mandate_10.csv"),
  verbose = TRUE, key = c("rcv_id", "pers_id"), 
  na.strings = c(NA_character_, "") )


### Votes ----------------------------------------------------------------------
pl_votes <- data.table::fread(
  file = here::here("data_out", "votes", "pl_votes_10.csv"), 
  select = c("activity_date", "rcv_id", "mandate", "number_of_attendees", 
             "number_of_votes_abstention", "number_of_votes_against",
             "number_of_votes_favor"), 
  na.strings = c(NA_character_, "") )

### MEP last Plenary day -------------------------------------------------------
meps_current <- data.table::fread( file = here::here(
  "data_out", "meps", "meps_current.csv") )

#------------------------------------------------------------------------------#
# get length objects
n_votes <- nrow(pl_votes)
n_rcv <- length( unique( meps_rcv_mandate$rcv_id ) )

#------------------------------------------------------------------------------#
# Hard code Groups
renew_group_ids <- political_groups$identifier[
  political_groups$label == "Renew"]
```

The objectives of this short note is to identify Renew Europe-compatible MEPs outside the group. 
It does that by calculating the  **affinity** (also called **similarity**) between Renew and all other MEPs.
<!-- * calculate **affinity** between Renew and all other national parties. -->

**Please keep in mind** that this document is the *sole property of the Renew Group* and *should not be disseminated to other people or organisations*.


## Affinity between Renew and other Groups' MEPs
### Overall affinity
In this section we calculate the affinity of all MEPs currently outside Renew with Renew's majority.
Affinity is defined as the frequency with which MEPs outside Renew have voted in the same way as Renew's majority.
To measure affinity, we consider only EP official votes, that is `for`, `against`, `abstain`.
```{r}
# Get the Groups' majority by rcv_id ------------------------------------------#
mjrt_groups <- get_polgroup_majority(
  data_in = meps_rcv_mandate[
    result >= -1] # exclude absent & no votes
)

# Get the target party majority
renew_mjrt <- mjrt_groups[
  polgroup_id %in% renew_group_ids]

# Inner-join
renew_othermeps <- renew_mjrt[
  meps_rcv_mandate[
    !polgroup_id %in% renew_group_ids
    & result >= -1L],
  on = "rcv_id", nomatch = NULL]

# Calculate affinity
renew_othermeps[, `:=`(
  is_same = as.integer(result == i.result) # 1 if same, 0 if different
)]

# take the average for plotting
renew_othermeps_avg <- renew_othermeps[, list(
  same_avg = round(mean(is_same, na.rm = TRUE) * 100, digits = 2) ),
  by = list(pers_id)
][order(-same_avg)]
```

The affinity score is bounded from 0% to 100%, 100% being exactly the same.
Below we report the full list.
```{r}
renew_othermeps_avg |>  
  dplyr::inner_join(
    y = meps_current, by = "pers_id") |> 
  join_polit_labs() |> 
  join_meps_names() |> 
  join_meps_countries() |> 
  dplyr::select(political_group, country_iso3c, national_party, mep_name, same_avg) |> 
  dplyr::arrange(desc(same_avg)) |> 
  knitr::kable(align = "c", 
               col.names = c("PG", "Country", "Party", "MEP Name", "Score (%)"))
```


### Affinity: 1-MEP Parties
If we focus on the MEPs belonging to 1-MEP parties, the table shrinks considerably.
```{r}
# Identify 1-MEP Parties
natparty_ids_1mep = meps_current[, .N, by = natparty_id][N == 1L][["natparty_id"]]

# plot -------------------------------------------------------------------------
renew_othermeps_avg |>  
  dplyr::inner_join(
    y = meps_current, by = "pers_id") |> 
  dplyr::filter(natparty_id %in% natparty_ids_1mep) |> 
  join_polit_labs() |> 
  join_meps_names() |> 
  join_meps_countries() |> 
  dplyr::select(political_group, country_iso3c, national_party, mep_name, same_avg) |> 
  dplyr::arrange(desc(same_avg)) |> 
  knitr::kable(align = "c", 
               col.names = c("PG", "Country", "Party", "MEP Name", "Score (%)"))
```


## Affinity Between Renew's Majority and Other National Parties
Here we calculate the affinity between the Renew's majorities, on the one hand, and all the non-Renew parties' majorities.
Considering the high number of parties, we filter them to just the parties that are *currently* represented in the House. 
```{r}
# Calculate party majorities
mjrt_parties <- get_natparty_majority(data_in = meps_rcv_mandate[
  polgroup_id != renew_group_ids
  & !is.na(natparty_id)
  & result >= -1L
])

# Inner join
renew_mjrt[, polgroup_id := NULL]
renew_parties <- renew_mjrt[
  mjrt_parties,
  on = "rcv_id"
][, c("who_won", "i.who_won") := NULL]

# Calculate Euclidean distance
renew_parties[, `:=`(
  is_same = as.integer(result == i.result) # 1 if same, 0 if different
)]

# take the average for plotting
renew_parties_avg <- renew_parties[, list(
  same_avg = round(mean(is_same, na.rm = TRUE) * 100, digits = 2) ),
  by = list(polgroup_id, natparty_id)
][order(-same_avg)]
```

Below we report the full list.
```{r}
renew_parties_avg |>  
  dplyr::inner_join(
    y = unique(meps_current[, list(country_id, polgroup_id, natparty_id)]), 
    by = c("polgroup_id", "natparty_id") ) |> 
  join_polit_labs() |> 
  join_meps_countries() |> 
  dplyr::select(country_iso3c, political_group, national_party, same_avg) |> 
  dplyr::arrange(desc(same_avg)) |> 
  knitr::kable(align = "c", 
               col.names = c("Country", "PG", "Party", "Score (%)"))
```


## Data and Methods
We include in our analysis all voting data relative to roll-call votes (RCVs) during the current mandate.
To provide some context, we currently have `r length(unique(meps_rcv_mandate$rcv_id))` RCVs in our database for the current mandate.
It is important to appreciate that what we have is only a subset of the all legislation being adopted. 
Indeed, the EP recognises different forms of voting - such as *raise of hands*, or *electronic votes* - but RCVs are the only ones where we able to trace votes to individual MEPs - that is, they are so-called *nominal* votes. 
As a rough approximation, if we take out the likely duplicate rows from the voting archives, RCVs were approximately `r round(n_rcv/n_votes*100, digits=1)`% of the total votes during this mandate.
