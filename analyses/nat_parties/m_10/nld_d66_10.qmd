---
title: "Communicating about voting data at national level"
author:
  - Marco SCIPIONI
date: "`r Sys.Date()`"
format: 
  html:
    embed-resources: true
    toc: true
    toc-depth: 4
    toc-title: Contents
    number-sections: true
    colorlinks: true
editor_options: 
  chunk_output_type: console
execute:
  echo: false
  warning: false
---

```{r qmdparams}
#------------------------------------------------------------------------------#
qmd_grid <- data.table::fread(here::here("data_reference", "qmd_grid.csv"))
params <- qmd_grid[qmd_grid$natparty_id == 6693L]

## Parameters ------------------------------------------------------------------
# Country
country_iso3c <- params$country_iso3c
country_name_en <- params$country_name_en

# Political Groups
renew_polgroup_id <- 7035L

# National Parties
renew_country_party_id <- params$natparty_id
renew_country_party <- params$national_party
renew_country_party_long <- params$national_party_long

renew_country_party_noshow_id <- qmd_grid$natparty_id[
  qmd_grid$country_id == params$country_id 
  & qmd_grid$natparty_id != renew_country_party_id
  & qmd_grid$polgroup_id == renew_polgroup_id]

independents <- c("-", "Ind.", "IndÃ©pendant", "Independent", "Independiente")
```


## Intro
```{r misc}
#| include: false

###--------------------------------------------------------------------------###
## Libraries -------------------------------------------------------------------
if ( !require("pacman") ) install.packages("pacman")
pacman::p_load(char = c("data.table", "dplyr", "ggplot2", "here", "lubridate",
                        "janitor", "stringi", "tidyr", "tidyselect", "tidytext") )


# Hard code the start of the mandate ------------------------------------------#
mandate_starts <- as.Date("2024-07-14")


###--------------------------------------------------------------------------###
## Functions -------------------------------------------------------------------
# https://stackoverflow.com/questions/2547402/how-to-find-the-statistical-mode
stat_mode <- function(x) {
  if ( length(x) <= 2 ) return(x[1])
  if ( anyNA(x) ) x = x[!is.na(x)]
  ux <- unique(x)
  ux[ which.max( tabulate( match(x, ux) ) ) ] }

# Cohesion rate ---------------------------------------------------------------#
source(file = here::here("scripts_r", "cohesionrate_function.R") )

# Join functions --------------------------------------------------------------#
source(file = here::here("scripts_r", "join_functions.R") )

# Calculate Majorities --------------------------------------------------------#
source(file = here::here("scripts_r", "get_majority.R") )


# Create output folder to dump temporary files
dir.create(path = here::here("data_out", "tmp", "natparty_tmp", "nld_d66"), 
           showWarnings = FALSE, recursive = TRUE)


#------------------------------------------------------------------------------#
## Graphics --------------------------------------------------------------------
# Vote Colours  ---------------------------------------------------------------#
vote_colours <- c(For = '#00AEEF',
                  Against = '#BE3455',
                  Abstain = "#969696",
                  `Did not vote` = '#5D5CA4',
                  Absent = '#F47920')

# political groups colours ----------------------------------------------------#
polgroup_cols = c(`S&D` = "#EE3652",
                  ECR = "#0D88C3",
                  PfE = "#1A3153",
                  PPE = "#3C5979",
                  Renew = "#FFCC70",
                  `Verts/ALE` = "#19A24A",
                  `The Left` = "#733542",
                  ESN = "#000000",
                  NI = "#979797")

# set theme globally for ggplots ----------------------------------------------#
# REF: https://stackoverflow.com/questions/34522732/changing-fonts-in-ggplot2
theme_set(theme_minimal(base_size = 10))
```

The objective of this short note is to provide regular updates to ***`r renew_country_party_long`*** (from now on, `r renew_country_party`) on Plenary voting dynamics.
At the time of writing, the sample size is extremely low, so the current figures may be somewhat misleading. 
Please consider this document just as a template that will become more reliable and insightful as data accumulates. 

In its standard version, this documents features three sections: 

* **Opposition MEPs who are both diverging from their Groups and close to `r renew_country_party_long`** looks at MEPs from national opposition parties who broke ranks with their respective Political Groups AND voted in the same way as `r renew_country_party_long`.
* **Opposition** investigates the instances and overall rates with which national opposition parties deviates from their respective Political Groups.
* **Extremism** in the EP. 

That said, if you have specific requests, or you would like to tailor this document according to other specifications, please do not hesitate to get in touch.

**Please keep in mind** that this document is the *sole property of the Renew Group* and *should not be disseminated to other people or organisations*.


## Data and Methods
We include in our analysis all voting data relative to RCVs since the start of the 10th mandate.
This means that we also get several MEPs who switched party and/or Group.
All these changes may translate into MEPs and parties featuring in different EP Political Groups.
For the sake of simplicity, in this analysis we discard MEPs' vote intentions, and *just display calculations relative to national MEPs and parties*.
```{r}
#| include: false

###--------------------------------------------------------------------------###
## Read data -------------------------------------------------------------------
# RCVs ------------------------------------------------------------------------#
meps_rcv_mandate <- data.table::fread(
  file = here::here("data_out", "meps_rcv_mandate_10.csv"),
  verbose = TRUE, key = c("rcv_id", "pers_id"), 
  na.strings = c(NA_character_, "") )

# Votes -----------------------------------------------------------------------#
pl_votes <- data.table::fread(
  file = here::here("data_out", "votes", "pl_votes_10.csv"), 
  na.strings = c(NA_character_, "") )  

# Vote dictionary -------------------------------------------------------------#
vote_dict <- data.table::fread(here::here("data_out", "votes", "vote_dict.csv") )


### MEP last Plenary day -------------------------------------------------------
meps_current <- data.table::fread( file = here::here(
  "data_out", "meps", "meps_current.csv") )

# get country nat_party id
country_parties_current <- sort( unique( meps_current$natparty_id[
  meps_current$country_id == params$country_id] ) ) 

# full list of Renew MEPs
renew_meps_full <- unique(meps_rcv_mandate$pers_id[
  meps_rcv_mandate$polgroup_id %in% renew_polgroup_id])


###--------------------------------------------------------------------------###
### MEPs mandate ---------------------------------------------------------------
meps_mandate <- data.table::fread(
  here::here("data_out", "meps", "meps_mandate_10.csv"))
```


## Opposition MEPs who are both diverging from their Groups and close to `r renew_country_party_long`
```{r}
# Get the Groups' majority by rcv_id ------------------------------------------#
who_won_bygroup <- get_polgroup_majority(
  data_in = meps_rcv_mandate[result >= -2]) # exclude absent

# Get Party majority ----------------------------------------------------------#
who_won_byparty <- get_natparty_majority(
  data_in = meps_rcv_mandate[result >= -2]) # exclude absent

## Calculate similarity --------------------------------------------------------
# Merge Group line with MEPs vote 
who_won_group_mep <- who_won_bygroup[
  meps_rcv_mandate, on = c("rcv_id", "polgroup_id") 
][i.result >= -2] # exclude absent

# Are Groups' majorities and MEP the same? ------------------------------------#
who_won_group_mep[, is_same := as.integer(result == i.result)]
```


### During last Plenary
What MEPs (not from Renew) voted in line with `r renew_country_party` when they deviated from their own group line?
Here we consider all types of votes, including the `no_vote` (i.e. a MEP present in the House but not voting), essentially getting rid only of those who are absent.
The vote dictionary is as follows:
```{r}
vote_dict |> 
  dplyr::filter(result >= -2) |> 
  knitr::kable(align = "c")
```

To answer that question, we first have to check whether non-Renew MEPs deviates from their Group.
```{r}
#| results: 'asis'

#------------------------------------------------------------------------------#
# First condition: non-Renew parties deviates from their Group ----------------#

# Create YEAR WEEK identifiers
pl_votes[, `:=`(
  year = data.table::year(activity_date),
  week = data.table::isoweek(activity_date)
)][,
   week := data.table::fifelse(test = nchar(week) == 1L, 
                               yes = paste0("0", week), no = as.character(week))
][,
  year_week := as.integer(paste0(
    year, week) ) 
][, c("year", "week") := NULL]
# Check 
# pl_votes[decision_method == "VOTE_ELECTRONIC_ROLLCALL",
#              length(unique(rcv_id)),
#              by = activity_date]

# Extract vector of RCV IDs from last Plenary
rcvids_lastplenary <- unique(pl_votes$rcv_id[
  pl_votes$decision_method == "VOTE_ELECTRONIC_ROLLCALL" # RCV only
  & pl_votes$year_week == max(pl_votes$year_week) # last Plenary only
  ] )

# Filter on just MEPs' deviations from Groups ---------------------------------#
group_meps_deviations <- who_won_group_mep[
  !polgroup_id %in% renew_polgroup_id # no Renew
  & is_same == 0L] |>  # mismatches only
  join_polit_labs() |>
  join_meps_names()

# Aggregate & plot ------------------------------------------------------------#
group_meps_deviations_plotdf <- group_meps_deviations[
  country_id %in% params$country_id
  & rcv_id %in% rcvids_lastplenary, # subset to last Plenary
  list(Count = .N), 
  keyby = list(political_group) ] |>
  dplyr::mutate(
    political_group = forcats::fct_reorder(political_group, Count) ) 

if ( nrow(group_meps_deviations_plotdf) == 0L ) {
  cat("During the last Plenary, there were __no occurrences__ of such deviations.\n",
      sep = "")
} else {
  cat("The bar chart below displays how many times MEPs have deviated from the Groups' majorities during the last Plenary.\n",
      sep = "")
}
```

```{r}
#| fig-width: 8
#| fig-height: 3

#------------------------------------------------------------------------------#
# Conditional plot ------------------------------------------------------------#
if ( nrow(group_meps_deviations_plotdf) > 0L ) {
  group_meps_deviations_plotdf |>
    ggplot(aes(x = political_group, y = Count)) +
    geom_col(linewidth = 0.1, colour = "black", fill = "grey80") +
    # geom_text(aes(label = Count), nudge_y = 0.5, size = 3) +
    labs(x = "", y = "Count", fill = "",
         title = "Count of MEPs' deviations from Group's majority - Last Plenary",
         caption = paste0("Note: data refers only to RCVs, other types of EP votes are not included. We only display data relative to ", country_iso3c) ) +
    theme_minimal() +
    coord_flip() +
    theme(plot.title.position = "plot",
          plot.title = element_text(face = "bold"),
          legend.text = element_text(face="bold"),
          panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
          panel.grid.minor.y = element_line(colour = "grey70"),
          axis.text = element_text(face="bold"),
          legend.position = "none") 
}
```

```{r}
#| results: 'asis'

if ( nrow(group_meps_deviations_plotdf) > 0L ) {
  cat("Having isolated the MEPs who deviated from the the Groups' majorities, we then proceed to single out whether any of those voted alongside ",
      renew_country_party,
      ". The table below lists the MEPs from the ",
      country_name_en,
      " who voted more frequently in the same way as ",
      renew_country_party,
      " and who did not follow their own Groups' majorities.\n",
      sep = "")
}
```

```{r}
if ( nrow(group_meps_deviations_plotdf) > 0L ) {
  
  # Merge Renew Party's majority with deviant MEPS ------------------------------#
  renewparty_deviantmeps <- merge(
    x = who_won_byparty[
      rcv_id %in% rcvids_lastplenary # subset to last Plenary
      & natparty_id %in% renew_country_party_id, # Just target Party
      list(rcv_id, result)],
    y = group_meps_deviations[
      country_id == params$country_id
      & rcv_id %in% rcvids_lastplenary, # subset to last Plenary
      list(rcv_id, i.result, country_id, polgroup_id, political_group, natparty_id,
           national_party, pers_id, mep_name) ],
    by = "rcv_id", all = FALSE)
  
  # Are Groups' majorities and MEP the same? ------------------------------------#
  renewparty_deviantmeps[, is_same := as.integer(result == i.result)]
  
  # Aggregate and print table ---------------------------------------------------#
  renewparty_deviantmeps[, list(
    Count = sum(is_same, na.rm = TRUE)), 
    keyby = list(country_id, political_group, national_party, mep_name) ] |>
    dplyr::filter(Count > 0L) |> 
    join_meps_countries() |> 
    dplyr::select(country_iso3c, political_group, national_party, mep_name, 
                  Count) |>
    dplyr::arrange(desc(Count)) |> 
    head(20) |> 
    knitr::kable(align = "c")
}
```


### Since the start of the parliamentary term
In this Section, we basically repeat the same calculations as above, only this time without any filtering to just the last Plenary. 
Thus, as above, the bar chart below displays how many times MEPs have deviated from the Groups' majorities since the start of the mandate. 
```{r}
#| fig-width: 8
#| fig-height: 3

#------------------------------------------------------------------------------#
# Aggregate & plot ------------------------------------------------------------#
group_meps_deviations[
  country_id == params$country_id, 
  list( Count = .N ),
  keyby = list(political_group) ] |> 
  dplyr::mutate(political_group = forcats::fct_reorder(political_group, Count)) |> 
  ggplot(aes(x = political_group, y = Count)) +
  geom_col(linewidth = 0.1, colour = "black", fill = "grey80") +
  # geom_text(aes(label = Count), nudge_y = 3, size = 3) +
  labs(x = "", y = "Count", fill = "",
       title = "Count of MEPs' deviations from Group's majority - Full mandate",
       caption = "Note: data refers only to RCVs, other types of EP votes are not included.") +
  theme_minimal() +
  coord_flip() +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold"),
        legend.text = element_text(face="bold"),
        panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
        panel.grid.minor.y = element_line(colour = "grey70"),
        axis.text = element_text(face="bold"),
        legend.position = "none")
```

Having isolated the MEPs who deviated from the the Groups' majorities, we then proceed to single out whether any of those voted alongside `r renew_country_party`.
The table below lists the top 20 MEPs who voted more frequently in the same way as `r renew_country_party` and who did not follow their own Groups' majorities.
```{r}
# Merge Renew Party's majority with deviant MEPS ------------------------------#
renewparty_deviantmeps <- merge(
  x = who_won_byparty[
    natparty_id %in% renew_country_party_id, # Just target Party
    list(rcv_id, result)],
  y = group_meps_deviations[
    country_id == params$country_id,
    list(rcv_id, i.result, country_id, polgroup_id, political_group, natparty_id,
         national_party, pers_id, mep_name) ],
  by = "rcv_id", all = FALSE)

# Are Groups' majorities and MEP the same? ------------------------------------#
renewparty_deviantmeps[, is_same := as.integer(result == i.result)]

# Aggregate and print table ---------------------------------------------------#
renewparty_deviantmeps[, list(
  Count = sum(is_same, na.rm = TRUE)), 
  keyby = list(country_id, political_group, national_party, mep_name) ] |>
  join_meps_countries() |> 
  dplyr::select(political_group, national_party, mep_name, Count) |> 
  dplyr::arrange(desc(Count)) |> 
  head(20) |> 
  knitr::kable(align = "c")
```

If we focus just on EPP, the top 5 MEPs are:
```{r}
# Aggregate and print table ---------------------------------------------------#
renewparty_deviantmeps[, list(
  Count = sum(is_same, na.rm = TRUE) ),
  keyby = list(country_id, political_group, national_party, mep_name) ] |>
  join_meps_countries() |> 
  dplyr::select(political_group, national_party, mep_name, 
                Count) |> 
  dplyr::arrange(desc(Count)) |> 
  dplyr::filter(political_group == "PPE") |> 
  knitr::kable(align = "c")
```


### Since the start of the parliamentary term, by Committee
```{r}
# List of RCV IDs & Committees -------------------------------------------------
rcvid_cmts_10 <- data.table::fread(input = here::here(
  "data_out", "rcv", "rcvid_cmts_10.csv") )

# Committees to focus upon
target_committees <- c("CONT", "CULT", "ECON", "EMPL", "ENVI", "FEMM", "ITRE",
                       "LIBE", "REGI")

# Merge Plenary Docs, RCV, Committees with deviant MEPs -----------------------#
dt_plot <- renewparty_deviantmeps[
  country_id == params$country_id 
  & is_same == 1L # filter to just same votes
][
  rcvid_cmts_10,
  on = "rcv_id", 
  nomatch = NULL] # inner join

# Aggregate and plot ----------------------------------------------------------#
dt_plot = dt_plot[, list(
  Count = sum(is_same, na.rm = TRUE) ), 
  keyby = list(country_id, political_group, national_party, mep_name,
               committee_lab) ] |>
  join_meps_countries() |> 
  # filter to just selected Committees ----------------------------------------#
  dplyr::filter(committee_lab %in% target_committees)

plot_height = as.integer(round(nrow(dt_plot)/6.5))
```

In this sub-Section, we present the same results as before, only this time grouped by Committee.
```{r}
#| fig-width: 8
#| fig-height: !expr plot_height

# REF: https://github.com/quarto-dev/quarto-cli/discussions/4028

#------------------------------------------------------------------------------#
dt_plot |>
  dplyr::mutate(mep_name = tidytext::reorder_within(
    mep_name, Count, committee_lab) ) |> 
  ggplot(aes(x = Count, y = mep_name, fill = political_group)) +
  geom_col(linewidth = 0.1, colour = "black") +
  # geom_text(aes(label = Count), nudge_y = 3, size = 3) +
  facet_grid(rows = vars(committee_lab), scales = "free_y", space="free_y") +
  labs(x = "Count", y = "", fill = "",
       title = "Count of MEPs' deviations from Group's majority - Full mandate",
       caption = "Note: data refers only to RCVs in Plenary.") +
  guides(fill = guide_legend(nrow = 1)) +
  tidytext::scale_y_reordered() +
  scale_x_continuous() +
  scale_fill_manual(values = polgroup_cols) +
  theme_minimal() +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold"),
        legend.text = element_text(face="bold"),
        legend.position = "top",
        panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
        panel.grid.minor.y = element_line(colour = "grey70"),
        axis.text = element_text(face="bold", size = 10),
        strip.text.y.right = element_text(angle = 0))
ggsave(filename = "p.jpeg")
```


## Opposition
```{r}
oppos_party_1 <- 6692L # Partij van de Arbeid
oppos_party_2 <- 6694L # GroenLinks
```

In this section we focus on `r renew_country_party`'s main opposition parties in the House. 


### Opposing coalition' splits during the last Plenary
Here we focus on the *Partij van de Arbeid* and *GroenLinks* coalition.
In particular, we ask whether we can observe instances where these two parties did not coincide in their majorities.
To calculate this, these parties must have expressed a majority.
Thus, the cases where either of these parties were split and did not express a majority are tossed out.
```{r}
# Merge 2 opposition parties
opposition_mjrt <- merge(
  x = who_won_byparty[natparty_id %in% oppos_party_1] |> 
    join_polit_labs(),
  y = who_won_byparty[natparty_id %in% oppos_party_2] |> 
    join_polit_labs(),
  by = "rcv_id", all = FALSE
)

opposition_mjrt[, is_same := as.integer(result.x == result.y)]
opposition_mjrt_plot <- opposition_mjrt |>
  dplyr::filter(
    is_same == 0L
    & rcv_id %in% rcvids_lastplenary # filter to just last Plenary
  ) |> 
  dplyr::select(rcv_id, 
                `Party 1` = national_party.x, 
                `Party 1 Majority` = result.x, 
                `Party 2` = national_party.y, 
                `Party 2 Majority` = result.y,
  )
```

```{r}
#| results: "asis"

if ( nrow(opposition_mjrt_plot) == 0L ) {
  cat("There were __no occurrences__ of such coalition splits during the last Plenary.\n",
      sep = "")
} else {
  cat("The table below lists the votes in which ",
      national_parties$label[national_parties$identifier == oppos_party_1],
      " and ",
      national_parties$label[national_parties$identifier == oppos_party_2], 
      " have split.\n",
      sep = "")
}
```

```{r}
if ( nrow(opposition_mjrt_plot) > 0L ) {
  opposition_mjrt_plot |> 
    knitr::kable(align = "c")
}
```

```{r}
#| include: false

if ( nrow(opposition_mjrt_plot) > 0L ) {
  # Write .csv to disk --------------------------------------------------------#
  dir.create(path = here::here("data_out", "tmp", "natparty_tmp",  "nld_d66"))
  
  opposition_mjrt |>
    dplyr::filter(
      is_same == 0L
      & rcv_id %in% rcvids_lastplenary # filter to just last Plenary
    ) |> 
    dplyr::select(rcv_id, 
                  `Party 1` = national_party.x, 
                  `Party 1 Majority` = result.x, 
                  `Party 2` = national_party.y, 
                  `Party 2 Majority` = result.y,
    ) |> 
    dplyr::left_join(
      y = pl_votes[, list(activity_date, rcv_id, doc_id, headingLabel_en,
                          referenceText_en, activity_label_en)],
      by = "rcv_id") |> 
    data.table::fwrite(file = here::here(
      "data_out", "tmp", "natparty_tmp",  "nld_d66", "pdva_gl_splits.csv") ) 
}
```


### Opposition parties' divergence with their respective Groups during the last Plenary
```{r}
who_won_group_party <- unique(
  # get the unique combination to anchor joins
  meps_rcv_mandate[
    !natparty_id %in% natparties_independent_ids, # no INDEPENDENT
    list(rcv_id, country_id, polgroup_id, natparty_id) ] ) |> 
  # inner join with Political Groups majority
  dplyr::inner_join(
    y = who_won_bygroup, by = c("rcv_id", "polgroup_id") ) |> 
  # inner join with National Parties majority
  dplyr::inner_join(
    y = who_won_byparty, by = c("rcv_id", "polgroup_id", "natparty_id") ) |> 
  data.table::as.data.table()


# Are Group and party majorities the same? ----------------------------------###
who_won_group_party[, is_same := as.integer(result.x == result.y) ]

who_won_group_party_print <- who_won_group_party[
  country_id == params$country_id # get just data from the target country
  & !polgroup_id %in% renew_polgroup_id # NO Renew
  & is_same == 0L # Only get divergences
  & rcv_id %in% rcvids_lastplenary # filter to just last Plenary
] |> 
  join_polit_labs() |> 
  dplyr::select(rcv_id, political_group, national_party,
                `Group Majority` = result.x,
                `Party Majority` = result.y) |> 
  dplyr::arrange(rcv_id, political_group, national_party) 
```

In this Section, we select the instances where national parties did not vote together with their own respective Political Groups in the last Plenary.
```{r}
#| results: "asis"

if ( nrow(who_won_group_party_print) == 0L ) {
  cat("There were __no such occurrences__ during last Plenary.\n", 
      sep = "")
} else{
  cat("The table below lists such occurrences, as well as how the majorities within both the Groups and parties have voted. We also produce a separate spreadsheet with further details on these votes.\n")
}
```

```{r}
if ( nrow(who_won_group_party_print) > 0L ) {
  who_won_group_party_print |> 
    knitr::kable(align = "c")
}
```

```{r}
#| include: false

if ( nrow(who_won_group_party_print) > 0L ) {
  
  # Write .csv to disk --------------------------------------------------------#
  who_won_group_party[
    country_id == params$country_id # get just data from the target country
    & !polgroup_id %in% renew_polgroup_id # NO Renew
    & is_same == 0L # Only get divergences
    & rcv_id %in% rcvids_lastplenary # filter to just last Plenary
  ] |> 
    join_polit_labs() |> 
    dplyr::select(rcv_id, political_group, national_party,
                  `Group Majority` = result.x,
                  `Party Majority` = result.y) |> 
    dplyr::arrange(rcv_id, political_group, national_party) |> 
    dplyr::left_join(
      y = pl_votes[, list(activity_date, rcv_id, doc_id, headingLabel_en,
                          referenceText_en, activity_label_en)],
      by = "rcv_id") |> 
    data.table::fwrite(file = here::here(
      "data_out", "tmp", "natparty_tmp",  "nld_d66", "opposition_group_party_splits.csv") ) 
}
```


### Opposition parties' alignment with their respective Groups since the start of the mandate
Now, instead of just focusing on the last Plenary, we calculate the frequency with which national parties have voted together with their own Groups since the start of the mandate.
In this Section, we toss out **independents** to simplify the presentation.
They can be brought back in at any time if needed. 
```{r}
#| fig-width: 8
#| fig-height: 3

who_won_group_party_avg <- who_won_group_party[
  country_id == params$country_id # get just data from the target country
  & !polgroup_id %in% renew_polgroup_id, # NO Renew
  list( align_share = mean(is_same, na.rm = TRUE) ),
  by = list(polgroup_id, natparty_id) ] 

who_won_group_party_avg |> 
  join_polit_labs() |> 
  dplyr::mutate(national_party = forcats::fct_reorder(
    national_party, align_share)) |> 
  ggplot(aes(x = national_party, y = align_share)) +
  geom_col(linewidth = 0.1, colour = "black", fill = "grey80") +
  facet_grid(rows = "political_group", scales = "free", space = "free") +
  labs(x = "", y = "Alignment Share (%)", fill = "",
       title = "National Parties' alignment with the respective Group's majority - Full mandate",
       caption = "Note: data refers only to RCVs, other types of EP votes are not included.") +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  coord_flip() +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold"),
        legend.text = element_text(face="bold"),
        panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
        panel.grid.minor.y = element_line(colour = "grey70"),
        axis.text = element_text(face="bold"),
        strip.text.y = element_text(angle = 0, face="bold"),
        legend.position = "none")
```


### Opposition parties' internal cohesion rates since the start of the mandate
Having looked at parties alignment with their respective Groups, we now check the extent to which national parties are internally cohesive. 
```{r}
#| fig-width: 8
#| fig-height: 3

#------------------------------------------------------------------------------#
# left join
meps_rcv_mandate <- vote_dict[meps_rcv_mandate, on = "result"]
# convert to factor - essential for tabulate
meps_rcv_mandate[, result_fct := factor(result_fct,
                                        levels = c("absent", "no_vote", "against",
                                                   "abstain", "for") ) ]
# Calculate Cohesion
cohesion_dt <- meps_rcv_mandate[
  country_id == params$country_id
  & result >= -1L, # only official votes
  list(
    cohesion = cohesion_hn(result_fct)
  ), 
  keyby = list(rcv_id, polgroup_id, natparty_id) ] 

cohesion_avg <- cohesion_dt[
  ! is.na(cohesion)
  & ! polgroup_id %in% renew_polgroup_id,
  list(
    cohesion_avg = mean(cohesion, na.rm = TRUE) ),
  by = list(polgroup_id, natparty_id)
] 

cohesion_avg |> 
  join_polit_labs() |> 
  dplyr::mutate(national_party = forcats::fct_reorder(
    national_party, cohesion_avg)) |> 
  ggplot(aes(x = national_party, y = cohesion_avg)) +
  geom_col(linewidth = 0.1, colour = "black", fill = "grey80") +
  facet_grid(rows = "political_group", scales = "free", space = "free") +
  labs(x = "", y = "Cohesion rate (%)", fill = "",
       title = "National Parties' internal cohesion rates - Full mandate",
       caption = "Note: data refers only to RCVs, other types of EP votes are not included.") +
  theme_minimal() +
  coord_flip() +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold"),
        legend.text = element_text(face="bold"),
        panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
        panel.grid.minor.y = element_line(colour = "grey70"),
        axis.text = element_text(face="bold"),
        strip.text.y = element_text(angle = 0, face="bold"),
        legend.position = "none")
```


<!-- ## Volt cross-national divergence and internal cohesion -->
<!-- ### Divergences of Volt's MEPs during last Plenary -->
```{r}
#| eval: false

# Identify Volt parties -------------------------------------------------------#
oppos_party_1 <- c(6638L) # Volt NLD
oppos_party_2 <- c(6859L) # Volt DEU

# Collapse 2 Volt parties into 1 ----------------------------------------------#
volt_mjrt <- meps_rcv_mandate[
  natparty_id %in% c(oppos_party_1, oppos_party_2),
  list(who_won = .N),
  by = list(rcv_id, result)]

# ensure that data is sorted so that subsequent filtering is correct ----------#
data.table::setorder(x = volt_mjrt, rcv_id, -who_won)

# Filter to just Volt's majority ----------------------------------------------#
volt_mjrt <- volt_mjrt[, head(.SD, 1L), keyby = list(rcv_id) ]


volt_mjrt_meps <- volt_mjrt[
  meps_rcv_mandate[
    natparty_id %in% c(oppos_party_1, oppos_party_2),],
  on = "rcv_id"]

# Check for same vote
volt_mjrt_meps[, is_same := as.integer(result == i.result)]
volt_mjrt_meps |>
  dplyr::filter(
    is_same == 0L
    # & rcv_id %in% rcvids_lastplenary # filter to just last Plenary
  ) |> 
  join_meps_names() |> 
  dplyr::select(rcv_id, `Volt majority` = result, mep_name, 
                `MEP's vote` = i.result) |> 
  knitr::kable(align = "c")
```

```{r}
#| include: false
#| eval: false

# Write .csv to disk ----------------------------------------------------------#
volt_mjrt_meps |>
  dplyr::filter(
    is_same == 0L
    # & rcv_id %in% rcvids_lastplenary # filter to just last Plenary
  ) |> 
  join_meps_names() |> 
  dplyr::select(rcv_id, `Volt majority` = result, mep_name, 
                `MEP's vote` = i.result)  |> 
  dplyr::left_join(
    y = pl_votes[, list(activity_date, rcv_id, doc_id, headingLabel_en,
                        referenceText_en, activity_label_en)],
    by = "rcv_id") |> 
  data.table::fwrite(file = here::here(
    "data_out", "tmp", "natparty_tmp",  "nld_d66", "volt_splits.csv") ) 
```

```{r}
#| eval: false

### Volt alignment with the Green Group

green_align <- data.table::rbindlist(
  l = list(
    # Green alignment, getting rid of Volt parties
    P = who_won_group_party[
      polgroup_id %in% c(7028)
      & !natparty_id %in% c(oppos_party_1, oppos_party_2),
    ], 
    # merge Volt INTERNATIONAL majority with Greens
    who_won_bygroup[
      polgroup_id %in% c(7028)
    ][volt_mjrt, on = "rcv_id"
    ][, `:=`(
      natparty_id = oppos_party_1,
      is_same = as.integer(result == i.result)
    )]
  ), use.names = TRUE, fill = TRUE
) |> 
  dplyr::group_by(polgroup_id, natparty_id) |> 
  dplyr::summarise(avg = mean(is_same, na.rm = TRUE) ) |> 
  dplyr::ungroup() |> 
  join_polit_labs() |> 
  dplyr::arrange(avg) 

# green_cohesion <- meps_rcv_mandate[
#   natparty_id == oppos_party_2, 
#   natparty_id := oppos_party_1
# ][
#   polgroup_id %in% c(7028),
#   list(
#     cohesion = cohesion_hn(votes_tally = result_fct )
#   ),
#   by = list(natparty_id, rcv_id)
# ][, list(
#     cohesion = mean(cohesion)/100
#   ),
#   by = list(natparty_id )
# ] |> 
#   join_polit_labs()

plot_rank <- green_align$national_party

green_align |> 
  dplyr::mutate(is_volt = ifelse(natparty_id == oppos_party_1, 0L, 1L),
                national_party = forcats::fct_reorder(national_party, avg)) |> 
  ggplot(aes(x = national_party, y = avg, fill = factor(is_volt) ) ) +
  geom_col(linewidth = 0.1, colour = "black") +
  labs(x = "", y = "Alignment (%)", fill = "",
       title = "Green Parties' alignment with the Group - Full mandate",
       caption = "Note: data refers only to RCVs, other types of EP votes are not included.") +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  coord_flip() +
  theme(plot.title.position = "plot",
        plot.title = element_text(face = "bold"),
        legend.text = element_text(face="bold"),
        panel.grid.major.y = element_line(colour = "grey30", linewidth = 0.1),
        panel.grid.minor.y = element_line(colour = "grey70"),
        axis.text = element_text(face="bold"),
        legend.position = "none")
```


## Extremism in the Parliament
### How the PVV votes when the Patriots are divided
Here, we first arbitrarily define a Political Group to be **split** when its *cohesion rate drops below 50*.
First, we count how many times has there been a split amongst the Patriots during the last Plenary.
```{r}
#| results: "asis"

#------------------------------------------------------------------------------#
# Calculate Cohesion
cohesion_polgroups <- meps_rcv_mandate[
  result >= -1L, # only official votes
  list(
    cohesion = cohesion_hn(result_fct)
  ), 
  keyby = list(rcv_id, polgroup_id) ] 

patriots_splits <- cohesion_polgroups[
  polgroup_id == 7150L 
  & cohesion < 50 
  & rcv_id %in% rcvids_lastplenary]

if ( nrow(patriots_splits) == 0L) {
  cat("There were __no splits__ within the _Patriots_ during the last Plenary.\n",
      sep = "")
} else {
  cat("There were __",
      nrow(patriots_splits),
      " splits__ within the _Patriots_ during the last Plenary.\n",
      sep = "")
}
```

For the Plenaries where there have been splits we produce a separate spreadsheet with the details of how PVV MEPs voted in those occasions. 
```{r}
if (nrow(patriots_splits) > 0L) {
  meps_rcv_mandate[
    rcv_id %in% patriots_splits$rcv_id
    & natparty_id %in% c(5302L, 6696L)
  ] |> 
    dplyr::left_join(
      y = pl_votes[, list(activity_date, rcv_id, doc_id, headingLabel_en,
                          referenceText_en, activity_label_en)],
      by = "rcv_id") |> 
    data.table::fwrite(file = here::here(
      "data_out", "tmp", "natparty_tmp",  "nld_d66", "patriots_splits_pvv.csv") ) }
```


### Dutch deviations towards ESN/PfE
In this sub-section we zoom in on the instances during the last Plenary where MEPs from neither from ESN or PfE did not follow their respective Groups but voted in the same way as either ESN or PfE. 
Pur differently, we select MEPs oly insofar as they meet three conditions: they are not from ESN or PfE; they vote in the same way as the majority of ESN or PfE; and they do not follow their respective Group majority.
We produce a separate spreadsheet with further details on these votes. 
```{r}
group_meps_deviations_plotdf <- group_meps_deviations[
  country_id %in% params$country_id # Filter to just country of interest
  & !polgroup_id %in% c(renew_polgroup_id, 7151L, 7150L)
  & rcv_id %in% rcvids_lastplenary, # Subset to last Plenary
] |> 
  # Merge with Group-wide ESN majority ----------------------------------------#
  dplyr::left_join(
    y = who_won_bygroup[
      polgroup_id == 7151L, 
      list(rcv_id, esn_mjrt = result)],
    by = "rcv_id"
  ) |> 
  # Merge with Group-wide PFE majority ----------------------------------------#
  dplyr::left_join(
    y = who_won_bygroup[
      polgroup_id == 7150L, 
      list(rcv_id, pfe_mjrt = result)],
    by = "rcv_id"
  ) |> 
  dplyr::mutate(
    is_pfe_esn = ifelse(test = i.result == esn_mjrt | i.result == pfe_mjrt,
                        yes = 1L, no = 0L)
  ) |> 
  dplyr::filter(is_pfe_esn == 1L) |> 
  dplyr::select(rcv_id, political_group, national_party, mep_name,
                mep_vote = i.result, esn_mjrt, pfe_mjrt) |> 
  dplyr::left_join(
    y = pl_votes[, list(activity_date, rcv_id, doc_id, headingLabel_en,
                        referenceText_en, activity_label_en)],
    by = "rcv_id") 

if ( nrow(group_meps_deviations_plotdf) > 0L) {
  data.table::fwrite(group_meps_deviations_plotdf, file = here::here(
    "data_out", "tmp", "natparty_tmp",  "nld_d66", "divergent_meps_esn_pfe.csv") ) 
}
```


### EPP's right turn
In this sub-section we select all votes during the last Plenary where the EPP voted differently from both Renew and S&D, and voted in the same way as ESN and PfE.
We produce a separate spreadsheet with further details on these votes. 
```{r}
epp_esn_pfe <- who_won_bygroup[
  rcv_id %in% rcvids_lastplenary, # subset to last Plenary
] 

if ( nrow(epp_esn_pfe) > 0L ) {
  epp_esn_pfe_wide <- epp_esn_pfe |> 
    join_polit_labs() |> 
    dplyr::select(-c(polgroup_id, who_won)) |> 
    tidyr::pivot_wider(names_from = political_group, values_from = result) |> 
    dplyr::mutate(
      is_pfe_esn = ifelse(
        test = PPE != Renew & PPE != `S&D` & (PPE == PfE | PPE == ESN),
        yes = 1L, no = 0L)
    )
}


if ( exists("epp_esn_pfe_wide") 
     && length(epp_esn_pfe_wide$is_pfe_esn == 1L) > 0L) {
  epp_esn_pfe_wide |> 
    dplyr::filter(is_pfe_esn == 1L) |> 
    dplyr::left_join(
      y = pl_votes[, list(activity_date, rcv_id, doc_id, headingLabel_en,
                          referenceText_en, activity_label_en)],
      by = "rcv_id") |> 
    data.table::fwrite(file = here::here(
      "data_out", "tmp", "natparty_tmp",  "nld_d66", "epp_esn_pfe.csv") ) 
}
```
